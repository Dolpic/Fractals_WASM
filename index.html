<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Fractals</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="index.css">
    <title>Fractals using WebAssembly</title>
  </head>
  <body onload="init()">
    <h1 class="main_title">Fractals using WebAssembly</h1>
    <p class="subtitle">Multi-threaded fractals computation</p>
    <hr>
    <section class="flex flex-wrap">
      <div id="controlPanel">
        <div id="normalControlPanel">
          <div class="controller">
            <label>Equation</label>
            <select id="selectedFunction" onchange="update()">
              <option value="1">Z=Z²+C</option>
              <option value="2">Z=Z³+C</option>
              <option value="3">Z=Z⁴+C</option>
              <option value="4">Z=Z²+C²</option>
              <option value="5">Z=Z²+Z+C²</option>
              <option value="6">Z=Z²+2Z+C²</option>
              <option value="7">Z=Z²+2Z+C²</option>
            </select>
          </div>
        </div>
        <details id="advancedControlPanel">
          <summary>Advanced options</summary>
          <div></div>
        </details>
      </div>
      <div id="canvasContainer">
        <canvas id=canvas></canvas>
      </div>
    </section>
    <hr>
    <div class="explanations">
      <p>
        This set is generated by a complex equation like
          <math>
            <msub><mi>Z</mi><mn>n+1</mn></msub>
            <mo>=</mo>
            <msup><msub><mi>Z</mi><mn>n</mn></msub><mn>2</mn></msup>
            <mo>+</mo>
            <mi>C</mi>
          </math> (for the original Mandelbrot set).
        <br>
        For each point <math><mi>C</mi></math> of the complex plane, starting with <math><msub><mi>Z</mi><mn>0</mn></msub><mo>=</mo><mn>0</mn></math>, the formula is computed recursively. <br>
        The set comprises all the points for which the norm does not tend toward infinity. Here it is approximated by having the norm staying below a given threshold after a given number of iterations. 
        To enhance the final image, points outside the set are colored from the "outside color" to the "highlight color" based on the number of iterations after which they exceeded the threshold.
      </p>
      <p>
        The computation is multithreaded using JavaScript workers, calling a WebAssembly module made using Rust. The image to render is split into multiple chunks (or tiles), and each worker is assigned a chunk to render. 
        This can be briefly seen when the image is refreshed: the image is updated "chunk by chunk". <br>
        As each chunk takes a different time to compute (chunks with a lot of points inside the set take significantly more time to render), a queue is created when a new image must be rendered.
        As soon as a thread has finished, it starts to compute the next chunk in the queue, this ensures all the workers are busy all the time, no matter which chunks are heavier to compute.
      </p>
      <p>
        Zooming at the edge of the set reveals a whole world of mesmerizing patterns. If the zoom becomes too high, the number of iterations may be too low, in that case, you can increase it in the advanced options.
      </p>

    </div>
     
    <script src="Fractal.js"></script>
    <script>
      fractal = undefined
      sliders = []

      function init(){
        addInput("imageWidth",  "Width",                 800)
        addInput("imageHeight", "Height",                800)
        addInput("imageZoom",   "Zoom",                  200, true,  200)
        addInput("imageX",      "X position",            0,   true, 1)
        addInput("imageY",      "Y position",            0,   true, 1)
        addInput("nb_workers",  "Number of threads",     15,  false, 0, true)
        addInput("chunkSize",   "Chunk size per thread", 100, false, 0, true)
        addInput("iterations",  "Iterations",            300, false, 0, true)

        addColor("colorIn",    "Color inside the set",  "#3fac84", true)
        addColor("colorOut",   "Color outside the set", "#173c54", true)
        addColor("colorHigh",  "Color highlight",       "#b4f9de", true)
        
        fractal = new Fractal(
          document.getElementById("canvas"),
          getInputVal("nb_workers")
        )
        updateColors()
        update()
      }

      function getInputVal(id){
        let obj = document.getElementById(id+"_text")
        return parseFloat(obj.value != "" ? obj.value : obj.placeholder)
      }

      function addInput(id, label_str, placeholder, has_slider=false, variance=0, isAdvanced=false){
        let container = document.createElement("div")
        container.className = "controller"

        let label = document.createElement("label")
        label.innerHTML = label_str

        let input_text = document.createElement("input")
        input_text.id          = id+"_text"
        input_text.placeholder = placeholder
        input_text.type        = "text"
        input_text.addEventListener("input", update)

        container.appendChild(label)
        container.appendChild(input_text)
        if(has_slider) {
          let input_range   = document.createElement("input")
          input_range.id    = id+"_range"
          input_range.type  = "range"
          input_range.min   = placeholder-variance
          input_range.max   = placeholder+variance
          input_range.value = (input_range.min + input_range.max) / 2
          input_range.step  = 0.001

          sliders.push(input_range)
          container.appendChild(input_range)
          input_text.addEventListener( "input", () => input_range.value = input_text.value)
          input_range.addEventListener("input", () => {input_text.value  = input_range.value; update()})
          input_range.addEventListener("change", updateSliders)
          input_range.value = input_text.placeholder
        }
        document.getElementById(isAdvanced?"advancedControlPanel":"normalControlPanel").appendChild(container)
      }

      function updateSliders(){
        sliders.forEach(s => {
          if(s.id == "imageZoom_range"){
            let val = s.value
            s.min  = 0.5*val
            s.max  = 1.5*val
            s.step = 1
          }else{
            s.min  = parseFloat(s.value) - 200/getInputVal("imageZoom")
            s.max  = parseFloat(s.value) + 200/getInputVal("imageZoom")
            s.step = 1/(10*getInputVal("imageZoom"))
          }
        });
      }

      function update(){
        fractal.set_parameters(
          document.getElementById("selectedFunction").value,
          [getInputVal("imageWidth"), getInputVal("imageHeight")],
          [getInputVal("imageX"),     getInputVal("imageY")],
          [getInputVal("imageZoom")],
          getInputVal("iterations"),
          getInputVal("chunkSize")
        )
        fractal.start_rendering()
      }

      function addColor(id, label_str, default_value, isAdvanced=false){
        let container =  document.createElement("div")
        container.className = "controller"

        let color = document.createElement("input")
        color.type = "color"
        color.id = id
        color.value = default_value

        let label = document.createElement("label")
        label.innerHTML = label_str

        container.appendChild(label)
        container.appendChild(color)
        document.getElementById(isAdvanced?"advancedControlPanel":"normalControlPanel").appendChild(container)
        color.addEventListener("change", updateColors)
      }

      function updateColors(){
        fractal.set_colors(
          document.getElementById("colorIn").value,
          document.getElementById("colorOut").value,
          document.getElementById("colorHigh").value
        )
        fractal.start_rendering()
      }
    </script>
  </body>
</html>
